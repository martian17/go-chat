package main

import (
    "log"
    "os"
    "net/http"
    "strconv"
    "time"
    "bytes"

    "github.com/gorilla/websocket"
)

var upgrader = websocket.Upgrader{}

func useIncludes() {
    //temp hack to use all includes
    //"imported and not used" is annoying af
    f,err := os.OpenFile("log.txt", os.O_RDWR | os.O_CREATE | os.O_APPEND, 0666)
    if err != nil {
        //never error, so can do anything
        //LMFAO this works!!
        time.Sleep(1 * time.Millisecond)
        log.Fatal(": ",
            strconv.FormatBool(true),
            http.DetectContentType([]byte{1}),
            bytes.Compare([]byte{1},[]byte{2}));
    }
    defer f.Close()
    log.Println("starting main");
}


//message "class" (class isn't really a thing in go but yk)
type Message struct {
    str string
    sender *Client
}


// client "class" (class isn't really a thing in go but yk)
type Client struct {
    //hub, doubly linked
    hub *Hub
    
    //connection pointer
    conn *websocket.Conn
    
    //this is how client recieves messages from the hub
    onMsg chan *Message
    sendMsg chan *Message
    
}

// Client constructor
func newClient(hub *Hub, conn *websocket.Conn){
    return &Client{
        hub:        hub,
        conn:       conn,
        onMsg:      make(chan *Message),
        sendMsg:    make(chan *Message)
    }
}

//methods

//will be ran under goroutine
func (this *Client) reader(){
    for{
        msgType, bytes, err := this.conn.readChannel()
        //msgType either websocket.TextMessage or websocket.BinaryMessage
        //bytes are of type []byte
        
        if err != nil {
            log.Println("Read Failed: ".err);
            break;
        }
        if msgType != websocket.TextMessage{
            continue;
        }
        
        this.sendMsg <- &Message{
            str:    string(bytes),
            sender: this
        }
    }
    //after error or connection close
    this.conn.Close();
}


func (this *Client) run(){
    this.hub.Register(this)
    go this.reader()
    for{
        select{
        case msg, ok := <- this.onMsg:
            //from the hub
            //send it to client
            err = conn.WriteMessage(websocket.TextMessage, []byte(strconv.Itoa(i)))
            if err != nil {
                log.Println("write failed:", err)
                break
            }
        case msg, ok := <- this.sendMsg:
            //from the client
            //send it to hub
            this.hub.sendMsg <- msg
        }
    }
    this.hub.Unregister(this)
    this.conn.Close()
}





// hub "class"
type Hub struct {
    // Registered clients.
    clients map[*Client]bool

    // Inbound messages from the clients.
    // use <- to read from it in each goroutine
    sendMsg chan *Message
    
    /*
    // Register requests from the clients.
    // will be generated by HandleFunc /socket each time client connets
    // will be consumed by go hub.run()
    register chan *Client

    // Unregister requests from clients.
    // will be generated by HanfleFunc /socket each time client terminates
    // will be consumed by go hub.run() 
    unregister chan *Client*/
}

// hub constructor
func newHub(){
    return &Hub{
        clients:    make(map[*Client]bool),
        sendMsg:    make(chan []byte),
        //register:   make(chan *Client),
        //unregister: make(chan *Client)
    }
}

func (this *Hub) Register(client *Client) {
    this.clients[client] = true
}

func (this *Hub) Unregister(client *Client) {
    delete(this.clients, client)
}


// hub pointer method
// will be run as goroutine
func (this *Hub) run() {
    
}









func main() {
    useIncludes()
    
    //runs for each client
    http.HandleFunc("/socket", func (w http.ResponseWriter, r *http.Request) {
        // Upgrade upgrades the HTTP server connection to the WebSocket protocol.
        conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil {
            log.Fatal("upgrade failed: ", err)
        }
        defer conn.Close()

        // Continuosly read and write message
        for i := 0;; i++{
            /*mt, message, err := conn.ReadMessage()
            if err != nil {
                log.Println("read failed:", err)
                break
            }
            input := string(message)
            cmd := getCmd(input)
            msg := getMessage(input)
            if cmd == "add" {
                todoList = append(todoList, msg)
            } else if cmd == "done" {
                updateTodoList(msg)
            }
            output := "Current Todos: \n"
            for _, todo := range todoList {
                output += "\n - " + todo + "\n"
            }
            output += "\n----------------------------------------"
            message = []byte(output)*/
            log.Println(i);
            err = conn.WriteMessage(websocket.TextMessage, []byte(strconv.Itoa(i)))
            time.Sleep(1000 * time.Millisecond)
            if err != nil {
                log.Println("write failed:", err)
                break
            }
        }
    })
    
    go hubLoop()
    
    http.Handle("/",http.FileServer(http.Dir("./static")))
    
    http.ListenAndServe(":9080", nil)
}
























